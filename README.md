<details>
<summary>MOMENTUM 클론코딩을 통한 javascript 연습 </summary>

목차 

	1. 서론 

	2. 자바스크립트 기초 

		2.1. 데이터 타입 

		2.2. 변수 선언 
	
		2.3. 배열 
	
		2.4. 객체(object) 

		2.5. 함수 

		2.6. 연산자 	

		2.7. Html 요소 찾기 

		2.8. Event 

	3. 이 프로젝트에서 배운 것들 

		3.1. 첫 화면 

		3.2. 배경화면 

		3.3. 시계 

		3.4. 명언 랜덤 출력 

		3.5. 해야 할 것들 목록  

	4. 결론 

 

 

 

 1.  서론 

Html, css에 이어 javascript를 연습하기 위해 노마드코더의 수업을 수강 후 배운 것들을 정리하고자 한다. 수업을 듣고 내용을 다시 정리하는 과정에서 얻는 것들은 가치 있다고 생각한다. 

 

2. 자바스크립트 기초 

 

2.1 데이터 타입 


Js에서 데이터 타입은 원시 값과 객체로 나뉜다. 

원시 값으로는 boolean, null, undefined, number, string, symbol이 있다. 

Boolean은 논리 요소를 나타내고, true와 false의 값을 가진다. 

null은 변수에 “값이 없음” 이 할당된 상태이다. 어떤 값이 의도적으로 비어 있음을 표현하며, boolean 연산에서는 거짓으로 취급한다. 

undefined는 변수에 값을 할당하지 않은 상태이다. 함수는 값을 명시적으로 반환하지 않으면 undefined를 반환한다. 

number는 숫자 데이터를 나타낼 때 사용한다. 데이터 타입을 검사할 때 해당 값이 숫자가 아니면 NaN이 출력된다. 

string은 텍스트 데이터를 나타낼 때 사용한다.  

symbol은 해당 요소의 고유함을 보장하고자 할 때 사용한다. 

 

2.2 변수 선언 


자바스크립트에서 변수를 선언하는 방법은 const, let, var 가 있다. 

기존 js에서는 var를 주로 사용했으나, 변수 선언 후 중복 선언이 가능한 등 코드가 길어질수록 오류가 날 가능성이 높았다.  

따라서 es6에서 let과 const가 나왔고, 현재 변수 선언에는 이 두 명령어를 주로 활용한다. 

const는 변수를 재선언 할 수 없고, 재할당도 할 수 없다. 
let은 변수를 재선언 할 수 없고, 재할당은 가능하다.  
var는 변수를 재선언 할 수 있고, 재할당도 가능하다.   

값을 재할당해야 할 것 같다면 let을, 아니라면 const를 사용하면 된다. 

js에서 변수를 선언할 때는 lowerCamelCase를 사용한다. 띄어쓰기가 필요한 단어의 맨 앞글자를 대문자로 표기하는 방식이다. 

 

2.3 배열 


배열은 데이터를 나열하기 위한 방법 중 하나이다. [] 안에 ,로 데이터들을 나열한다. 숫자, 문자, boolean 등 데이터 타입들을 정렬할 수 있다. 

Ex) const exerciseSupplements = [ protein, creatine, BCAA, booster ] 일 때  

해당 배열에서 4번째 값을 출력하고자 한다면 console.log(exerciseSupplements[3]); 을 해야 한다. 

Js 배열은 0부터 시작한다. 따라서 첫 번째 값은 0, 두 번째 값은 1이다. 
따라서 n번째 값을 얻고 싶다면 array[n-1] 값을 불러와야 한다.  

일반적으로 const로 선언된 값은 변경이 불가능하나, const로 배열을 선언했음에도 배열 안의 내용들은 변경이 가능하다. 객체의 경우 객체가 저장된 공간을 가리키는 정보만 상수이고, 객체 안의 내용들은 아니기 때문이다. 

 

2.4 객체 


객체는 여러 속성을 하나의 변수에 저장할 수 있게 해주는 데이터 타입이다. key와 value로 이루어져 있다. 

객체는 변수이나, 중괄호 표기를 이용하여 다량의 key/value에 대한 정보를 나열할 수 있다.  
이때 key는 문자열 또는 기호여야 하고, value는 모든 유형이 될 수 있다. 객체에서 명명된 값을 properties 라 한다. 

객체의 종류에는 배열, 함수, 날짜, 수학, 정규표현식 등 원시값을 제외한 모든 javascript의 값은 객체이다.  

객체는 크게 js 내장 객체, 브라우저 내장 객체, 사용자 정의 객체 3가지로 구분하고 있다. 

Js 내장 객체로는 Date,Array, Math 등이 있다.  
브라우저 내장 객체로는 BOM(브라우저 객체 모델), DOM(문서 객체 모델)이 있다. 
사용자 정의 객체는 말 그대로 사용자가 정의하고 확장시킨 객체들이다. 

property는 객체의 속성을 나타내는 key와 value를 가진 형태이다. 이때 key에 symbol 외의 값을 정의하면 데이터타입이 변경되어 문자열이 된다. 나중에 선언한 프로퍼티는 먼저 선언한 프로퍼티를 덮어쓰며, 객체는 프로퍼티를 나열할 때 순서 없이 나열된다. 

 

2.5 함수


Function은 코드를 재사용하기 위해 만들어진다. 특정 코드를 함수로 정의해 캡슐화 한 후 여러 번 실행할 수 있게 한다.  

함수는 아래와 같은 형태로 사용할 수 있다. 

 Function 함수명 ( 변수1, 변수2, …,) {  

함수 내용; 

} 

함수명(변수1, 변수2); 

함수에는 매개변수(parameter)와 인자(arguement)가 있다. 

Parameter는 함수를 정의할 때 함수가 받을 입력값을 지정하는 변수이다. 함수 내에서 사용되는 변수로써, 함수 선언 시 괄호 안에 나열되며 이름과 데이터 타입을 가진다. 

Ex) function hungry(food) { 

Console.log(`I want to eat ${food}`); 

} 

의 함수에서 food는 매개변수이다. 

Arguement는 함수를 호출할 때 전달되는 값들이다. 함수를 호출할 때 괄호 안에 인자를 넣어 전달하면, 해당 인자들이 함수의 매개변수에 할당된다. 이때 인자의 갯수와 순서는 매개변수와 일치해야 한다. 

Ex) hungry(“chicken”); 의 코드에서 “chicken”이 인자이다. 

함수에는 return 코드가 있어, 함수에서 얻은 값을 변수로 할당해 그 값을 사용할 수 있다. 
다만 함수 내부에서 return이 실행될 경우 해당 함수는 바로 종료된다. 

함수에 값을 보내는 게 인자, 받는 게 매개변수라 이해했다. 


2.6 연산자 


Js에서 연산자를 통해 할당, 비교, 산술, 비트 계산, 논리, 문자열, 삼항 등 다양한 명령을 내릴 수 있다. 

비교 연산자 

피연산자들을 비교하고, 결과가 참인지에 따라 논리값을 반환한다.  
동등(==), 부등(!=), 일치(===), 불일치(!==) 등의 기호가 있다. 
동등은 피연산자가 서로 같아야 하고, 일치는 이에 타입까지 같아야 한다. 

논리 연산자 

논리 연산자는 불리언 값과 함께 사용하여 불리언 값을 반환한다.  
and(&&), or(||), not(!) 등의 기호가 있다. 

Typeof 연산자 
피연산자의 타입을 나타내는 문자열을 반환할 수 있다. 

이외 등 많 연산자들이 있다. 

 

2.7 HTML 요소 찾기 


querySelector를 통해 html의 요소를 찾을 수 있다. Js에서 html을 수정하기 위해서는 js에서 우선 html의 특정 요소에 대해 정의해야 하기 때문에 자주 사용한다. 

Html에 없는 요소를 만들고자 한다면 createElement()를 통해 요소를 생성할 수 있다. 
다만 이때 생성한 요소는 appendChild()를 통해 document 상에 추가해야 화면을 통해 볼 수 있다. 


2.8 event 


Js에서 이벤트는 클릭, 스크롤, 무언가 입력하는 등의 상호작용으로 인해 발생하는 특정 사건을 의미한다. 모든 이벤트는 eventListener를 통해 js가 들을 수 있다.  

function eventHandler() { 

	Element.style.color=”grey” 

} 

Element.addEventListener(“click”, eventhandler) 

라는 코드가 있을 때, addEventListener 안의 함수에 ()를 붙이지 않은 이유는 이벤트 발동시에만 해당 함수를 작동시키기 위함이다. 해당 함수에 ()를 붙이면 바로 작동함. 

듣고 싶은 이벤트가 있다면 console.dir(element)를 통해 다양한 property들을 검색하여 사용 가능한 event를 찾을 수 있다. 이벤트 리스너는 property 앞에 on이 붙어있는 것을 통해(ex. Onclick 등) 확인할 수 있다. 해당 이벤트 리스너를 사용할 때는 앞에 on를 빼고 사용해야 한다. 

 

3 이 프로젝트에서 배운 것들 

 

3.1 첫 화면 


Html에서 로그인 화면 혹은 환영 화면을 띄우려고 한다. 해당 목표를 이루기 위해 classList 기능을 사용했다. 

각각의 화면에 div를 두고 해당 클래스와 hidden 클래스를 부여한다. css를 통해 hidden 클래스가 부여된 div는 화면에서 없애고, 조건을 통해 각 div 중 하나의 div만 해당 div의 classList 중 하나인 hidden을 제거해 볼 수 있게 한다. 

form에서 submit을 하면 브라우저는 새로고침된다. Form 안의 input을 submit 해도 해당 정보는 새로고침되면서 사라지기 때문에 event.preventDefault를 통해 브라우저 새로고침을 막았다. 브라우저 새로고침이 되지 않으면 submit 받은 정보가 그대로 남아있기 때문에 해당 정보를 활용할 수 있다. 
다만 반드시 form 안의 input이여야 정보를 받을 수 있다. div는 불가능하다. 여기서 받은 정보를 보관하기 위해 localStorage에 저장한다. 이후 받은 정보를 토대로 사용자의 이름을 화면에 보이는 함수를 실행한다. 

Js는 인자를 담아서 함수를 호출한다. 이 인자는 js가 기본적으로 제공하는 정보를 담을 수 있다. 함수의 인자가 없다면 이벤트에 대한 정보를 받을 수 없다. 함수의 괄호 안에 있는 인자의 이름으로 js에서는 발생한 event에 대한 정보를 준다. 관행적으로 function(event)라 적는다.    

js를 통해 html에 텍스트를 추가할 수 있다. OnLoginSubmit에서 paintGreetings로 username에 해당하는 인자를 보내면, paintGreetings 함수에서는 해당 값을 매개변수로 받아 .innerText 함수를 통해 화면에 띄운다. 이때 “Hello” + username 대신 한 괄호 안에 변수까지 포함한 값을 적고 싶다면, `` 백틱을 사용하여 `Hello ${username}`이라 할 수 있다. 

이 상황에서 페이지를 새로고침하면, localstorage에 값이 저장되어 있음에도 불구하고 처음 로그인 창부터 다시 나타난다. 이를 막기 위해 localstorage에 값이 있는지 확인하고, 저장된 값이 없다면 로그인 폼의 classList 중 hidden을 제거하고, 값이 있다면 값을 화면에 띄우는 함수를 작동시킨다. 

해당 코드를 적으며 hidden, username과 같은 변수명들이 자주 사용되었다. 변수명의 오타로 인한 오류는 js에서 잡아내지 못하기 때문에, 해당 변수명들을 각각 상수로 선언해서 사용했다. 

Ex) const HIDDEN_CLASSNAME=”hidden”;   

상수는 변수명과 구분될 수 있게 대문자로 하는 게 관례이다. 값이 변하지 않음을 타인들에게 알리기 위함이다. 변수명을 상수로 지정함으로써 오타로 인한 오류를 잡아낼 확률을 줄이고, 유의미한 상수명을 부여함으로써 코드 가독성을 올릴 수 있다. 

 

3.2 배경화면


출력하고자 하는 이미지를 각각 정의하고, 정의한 이미지들을 리스트에 넣었다. Math.random 함수를 통해 0~1 사이에 있는 임의의 수를 출력하고, 리스트의 요소 갯수만큼 곱한 뒤  Math.floor 함수를 통해 소숫점 이하의 수들을 모두 버렸다. 그렇게 리스트의 요소 갯수가 n일 때 0~n-1인 임의의 수를 얻을 수 있었다. 

임의의 수 r을 리스트[r]에 넣어 얻은 임의의 이미지를 chosenImage라 정의한다. 

배경화면에 넣고자 하는 이미지를 bgImage= document.createElement("img"); 라 정의하여 이미지 요소를 참조하는 객체로 만든다. 따라서 출력하고자 하는 이미지의 소스를 bgImage.src에 할당한 뒤 appendChild를 통해 html에 삽입한다면 랜덤한 이미지를 출력할 수 있다. 

해당 부분을 진행하며 bgimage.src=chosenImage라 정의하여 오류가 발생했었다. 이렇게 코드를 짜면 bgimage가 참조해야 할 속성이 이미지 요소 자체가 되기 때문에 출력되지 않는 오류가 발생했었다.  

같은 맥락으로 bgimage=chosenImage.src;라 정의해도 오류가 발생한다. BgImage의 속성에 출력하고자 하는 이미지의 속성이 직접 할당되지 않아 이미지가 출력되지 않는다.  

 

3.3 시계 


Html의 clock 부분을 querySelector를 통해 정의한다. GetClock이라는 함수를 하나 만들고, 이후 date=new date() 함수를 통해 date 타입을 가진 객체를 생성한다.  

Hour를 date.getHours(), minutes를 date.getminutes(), seconds를 date.seconds로 각각 정의한다. 이후 html의 clock에 변수로 지정한 hours, minutes, seconds를 각각 innertext로 집어넣는다.  

마지막으로 setInterval 함수를 통해 getClock 함수를 매 초마다 실행시켜 시간을 얻을 수 있다. 이때 setInterval을 통해 getClock 함수를 실행하면 첫 1초간은 getClock 함수가 작동하지 않기에 시간이 보이지 않는다. 따라서 그냥 getClock 함수를 한 번 작동시킨다. 

이 방식을 통해 html에 시계를 만들 수 있으나, 시간이 01초일 때 00:00:1, 1분일 때 00:1:1로 나오는 현상이 발생한다. 이를 해결하기 위해 date.getHours를 통해 얻은 값을 string으로 바꾸고, padstart 함수를 통해 만약 값이 한자리 수일 때, 빈 공간에 0을 채워넣는다. 이 방식을 통해 00:00:00 의 형태가 깨지지 않는 시계를 만들었다. 

 

3.4 명언 랜덤 출력 


10개의 랜덤한 명언을 글귀와 저자로 나누어 객체 배열 형태로 저장한다. Quotes는 객체 배열이며, quote와 author라는 속성을 가지고 있다. 

이후 html의 첫 번째 span을 quote로, 두 번째 span을 author로 정의한 뒤 quotes의 배열에서 랜덤으로 하나를 선택해 quote를 quote에, author를 author에 각각 innerText를 통해 추가한다. 

 

3.5 해야 할 것들 목록 


해야 할 것들 목록을 작성하기 위해 html에 form을 하나 만든다. Form 안에는 input을 두고, input을 통해 입력받은 값을 저장해둘 ul도 하나 만든다. 

우선 input이 submit되는 이벤트를 감지하는 함수를 하나 만든다. 이 이벤트를 감지할 시 다음 함수를 작동하도록 한다. 

input이 Submit될 때, event.preventDefault()를 통해 페이지의 새로고침을 막은 뒤, Input에서 입력받은 값을 newTodo로 정의한다. 새로고침을 막았기 때문에 input 칸의 값들도 여전히 남아있는 상태이다. 따라서 수동으로 input의 입력값들을 공백으로 수정해준다. 이 다음, 입력받은 값들을 text와 id로 구성된 객체로 정의한다. Id까지 구성된 객체로 구성하는 이유는 localstorage에서 지울 때 객체를 구별해서 지우기 위함이다.  

form의 input에서 입력받은 값을 ul에 추가할 함수를 만들어야 한다. li 요소와 span요소, button 요소를 각각 html상에 만든다.  이는 각각 html상에서 ul 안에 li를 만들고, li 안에 span과 button을 각가 만들기 위함이다. 입력받은 값을 화면상에 표기하는 paintToDo 함수는 입력받은 값을 매개변수로 받았다. 입력받은 값을 출력하고, 그 옆에 삭제 버튼까지 만들었다면, 삭제 버튼을 클릭했을 때 화면 상에서 지우는 함수를 작동하게 한다. 

다만 이 방식으로 한다면 새로고침을 할 때 등록한 모든 list들이 사라진다. 이를 막기 위해 localStorage를 활용하여 li들을 저장해야 한다. 리스트를 만들고, 입력받은 값들을 리스트에 저장한 뒤 이 리스트를 localStorage에 저장하는 방법을 사용했다.  

LocalStorage에는 string 타입의 값들만 저장할 수 있다. 하지만 우리가 리스트에 추가한 뒤 저장하고자 하는 값은 text와 id로 이루어진 객체이다. 객체를 localStorage에 저장하면 {object object}만 저장된다.  따라서 JSON.stringify를 통해 객체 배열들을 모두 string으로 바꿔준 뒤 localStorge에 올린다. 이렇게 올린 배열들은 JSON.parse를 통해 객체로 복구할 수 있다.  

이제 localStorage에 저장된 값이 있는지 확인하고, 저장된 값이 있다면 해당 값들을 JSON.parse를 통해 객체로 복구한 뒤, 리스트를 복구한 배열로 정의한다. 이 리스트에 담긴 각각의 객체마다 화면에 출력하는 함수를 통해 값들을 출력한다. 

하지만 이 방법을 통해서도 새로고침 후 input에 새 값을 입력하면 모든 localStorage가 사라지고 새로 입력한 값만 남는다. 이는 빈 리스트를 const로 정의했기 때문으로, 매번 빈 리스트에 값을 저장해 기존 값들이 사라지는 것이었다. Let을 통해 리스트를 정의함으로써 해당 리스트가 변화할 수 있게 한다면, 새로운 값을 입력해도 리스트에 잘 저장된 채 초기화되지 않는다. 

삭제 함수를 만들 때 단순히 버튼을 눌러서 생성된 li를 지우는 식으로 하면 모든 li가 지워진다. 이를 방지하기 위해 함수에 event 매개변수를 둔 뒤, event.target.parentElement를 통해 버튼의 상위 요소를 파악한다. 버튼의 상위 요소는 text와 button으로 이루어진 list이고, 이 리스트를 지움으로써 원하는 리스트만 지울 수 있다. 

하지만 localStorage는 지우지 못 했기에 새로고침시 지운 리스트가 다시 나타난다. 이는 filter 함수를 통해 배열을 다시 만든 후 다시 만든 배열을 localStorage에 저장해 갱신하는 방법을 사용할 것이다. 

Filter 함수는 배열의 값 만큼 작동하는 함수로, 조건을 걸고 false가 반환되는 객체를 제외한 나머지 객체들로 배열을 만든다. 이 경우에 조건은 “지운 객체의 id와 배열에 있는 객체의 id가 불일치하는가” 이다.  

 

4. 결론
   

Js 기초 강의를 들으며 객체와 연산자 등의 기본적인 개념들과 언어의 사용법들을 배을 수 있었다. 좋은 강의를 들으며 해당 논리를 이해하고 따라하는 것은 할 수 있었지만 혼자 논리를 구상해서 적용하기에는 아직 무리가 있을 듯 하다. Css를 통해 꾸며볼까 했지만 다른 프로젝트를 통해 js에 더 익숙해지는 게 더 나을 것 같아 생략했다. 더 노력하고 더 익숙해져서 더 나은 사람이 되고자 한다. 

</details>
